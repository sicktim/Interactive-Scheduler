<!-- Interactive Scheduler v3.1 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TPS Interactive Scheduler</title>
    <meta name="theme-color" content="#1a1a2e">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap');

        * { font-family: 'JetBrains Mono', monospace; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            height: 100vh;
            overflow: hidden;
            margin: 0; padding: 0;
            color: #e2e8f0;
        }

        #root { height: 100vh; }

        /* ===== APP LAYOUT ===== */
        .app-layout {
            display: grid;
            grid-template-columns: 1fr 300px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
        }

        .app-header {
            grid-column: 1 / -1;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 8px 16px;
            z-index: 60;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .timeline-area {
            grid-column: 1;
            grid-row: 2;
            overflow: auto;
            position: relative;
            background: rgba(0,0,0,0.15);
        }

        .change-summary-panel {
            grid-column: 2;
            grid-row: 2 / 4;
            background: rgba(20, 20, 40, 0.95);
            border-left: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .picker-panel {
            grid-column: 1;
            grid-row: 3;
            background: rgba(20, 20, 40, 0.98);
            border-top: 1px solid rgba(255,255,255,0.1);
            max-height: 160px;
            overflow-y: auto;
            z-index: 50;
        }

        /* ===== DAY COLUMNS ===== */
        .days-container { display: flex; min-height: 100%; }

        .day-column {
            min-width: 750px;
            width: 750px;
            border-right: 2px solid rgba(255,255,255,0.06);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .day-header {
            position: sticky;
            top: 0;
            z-index: 40;
            background: rgba(30, 30, 60, 1);
            border-bottom: 1px solid rgba(255,255,255,0.15);
            padding: 6px 10px 0 10px;
            height: 52px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .timeline-ruler {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.4);
            padding: 0 2px;
            position: relative;
            height: 14px;
        }

        .timeline-ruler span {
            position: absolute;
            transform: translateX(-50%);
        }

        .day-body { flex: 1; padding: 4px 0; }

        /* ===== SECTION HEADERS ===== */
        .section-divider {
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 3px 10px 2px;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            user-select: none;
        }

        .section-divider-flying { color: #6ee7b7; background: rgba(16, 185, 129, 0.06); }
        .section-divider-ground { color: #fde68a; background: rgba(245, 158, 11, 0.06); }
        .section-divider-na { color: #fca5a5; background: rgba(239, 68, 68, 0.06); }

        .section-lanes { position: relative; margin: 2px 0; overflow: hidden; }

        /* ===== EVENT CARDS ===== */
        .event-card {
            position: absolute;
            border-radius: 4px;
            cursor: default;
            transition: box-shadow 0.15s, filter 0.15s;
            display: flex;
            flex-direction: column;
            z-index: 5;
            overflow: hidden;
            min-width: 140px;
        }

        .event-card:hover {
            z-index: 20;
            filter: brightness(1.15);
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
            overflow: visible;
        }

        .event-card.drag-over {
            box-shadow: 0 0 0 2px #3b82f6, 0 0 16px rgba(59,130,246,0.5) !important;
            z-index: 25;
        }

        .event-card-flying {
            background: rgba(16, 185, 129, 0.18);
            border: 1px solid rgba(16, 185, 129, 0.45);
        }
        .event-card-ground {
            background: rgba(245, 158, 11, 0.18);
            border: 1px solid rgba(245, 158, 11, 0.45);
        }
        .event-card-na {
            background: rgba(239, 68, 68, 0.18);
            border: 1px solid rgba(239, 68, 68, 0.45);
        }

        /* Event card title bar */
        .event-title-bar {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            font-size: 0.58rem;
            line-height: 1.2;
            min-height: 16px;
            background: rgba(0,0,0,0.15);
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .event-type-label {
            font-weight: 700;
            font-size: 0.58rem;
            padding: 0 4px;
            border-radius: 2px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .label-flying { background: rgba(16,185,129,0.35); color: #a7f3d0; }
        .label-ground { background: rgba(245,158,11,0.35); color: #fef3c7; }
        .label-na { background: rgba(239,68,68,0.35); color: #fecaca; }

        .event-name-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: rgba(255,255,255,0.85);
        }

        .event-time-text {
            margin-left: auto;
            font-size: 0.5rem;
            color: rgba(255,255,255,0.35);
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* Flight bar (ETD-ETA) */
        .flight-bar-row {
            position: relative;
            height: 12px;
            margin: 1px 6px;
        }

        .flight-bar-track {
            position: absolute;
            top: 2px;
            left: 0; right: 0;
            height: 8px;
            background: rgba(255,255,255,0.04);
            border-radius: 2px;
        }

        .flight-bar-fill {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(16, 185, 129, 0.5);
            border-radius: 2px;
            border-left: 2px solid rgba(16, 185, 129, 0.9);
            border-right: 2px solid rgba(16, 185, 129, 0.9);
        }

        .flight-time-marker {
            position: absolute;
            top: -1px;
            font-size: 0.45rem;
            color: rgba(16,185,129,0.7);
            line-height: 1;
        }

        .flight-time-marker.etd { transform: translateX(-100%); padding-right: 2px; }
        .flight-time-marker.eta { transform: translateX(0%); padding-left: 2px; }

        /* Crew area */
        .event-crew-area {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            padding: 2px 5px 3px;
            align-items: center;
        }

        /* ===== PERSONNEL CHIPS ===== */
        .chip {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 0.58rem;
            font-weight: 500;
            cursor: grab;
            user-select: none;
            white-space: nowrap;
            line-height: 1.3;
            position: relative;
            transition: transform 0.1s, box-shadow 0.1s;
            z-index: 10;
        }

        .chip:hover { filter: brightness(1.25); box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
        .chip:active { cursor: grabbing; }

        .chip-remove {
            cursor: pointer;
            font-size: 0.5rem;
            opacity: 0.4;
            margin-left: 1px;
        }
        .chip-remove:hover { opacity: 1; color: #ef4444; }

        .chip-conflict {
            outline: 2px solid #fbbf24;
            outline-offset: -1px;
            box-shadow: 0 0 6px rgba(251,191,36,0.5);
            animation: conflict-pulse 2s ease-in-out infinite;
        }

        @keyframes conflict-pulse {
            0%, 100% { outline-color: rgba(251,191,36,0.9); box-shadow: 0 0 6px rgba(251,191,36,0.5); }
            50% { outline-color: rgba(251,191,36,0.4); box-shadow: 0 0 3px rgba(251,191,36,0.2); }
        }

        .conflict-icon { color: #fbbf24; font-size: 0.55rem; font-weight: 700; }

        .add-chip {
            padding: 1px 4px;
            border: 1px dashed rgba(255,255,255,0.2);
            border-radius: 3px;
            color: rgba(255,255,255,0.25);
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        .add-chip:hover {
            border-color: #3b82f6;
            color: #3b82f6;
            background: rgba(59,130,246,0.1);
        }

        /* Conflict badge on event card */
        .conflict-badge {
            position: absolute;
            top: -3px; right: -3px;
            min-width: 14px; height: 14px;
            background: #ef4444;
            border-radius: 7px;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.45rem; font-weight: 700;
            color: white; z-index: 20;
            box-shadow: 0 0 6px rgba(239,68,68,0.6);
            padding: 0 3px;
        }

        /* Conflict tooltip (portal - rendered at app root with position:fixed) */
        .conflict-tooltip-portal {
            position: fixed;
            background: #1e1e3a;
            border: 1px solid #ef4444;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 0.5rem;
            color: #fca5a5;
            white-space: pre-line;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            max-width: 320px;
        }

        /* ===== PICKER ===== */
        .picker-tabs {
            display: flex;
            gap: 1px;
            overflow-x: auto;
            flex-shrink: 0;
        }

        .picker-tab {
            padding: 4px 8px;
            font-size: 0.55rem;
            font-weight: 600;
            color: rgba(255,255,255,0.35);
            cursor: pointer;
            white-space: nowrap;
            border-bottom: 2px solid transparent;
            transition: all 0.15s;
        }
        .picker-tab:hover { color: rgba(255,255,255,0.6); }
        .picker-tab.active { color: #3b82f6; border-bottom-color: #3b82f6; }

        .picker-body {
            padding: 6px 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            overflow-y: auto;
        }

        .picker-chip { cursor: grab; }
        .picker-chip.busy::after {
            content: '';
            position: absolute;
            top: -1px; right: -1px;
            width: 5px; height: 5px;
            border-radius: 50%;
            background: #f59e0b;
        }

        .picker-search {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            padding: 3px 8px;
            font-size: 0.6rem;
            color: white;
            outline: none;
            width: 140px;
        }
        .picker-search:focus { border-color: #3b82f6; }
        .picker-search::placeholder { color: rgba(255,255,255,0.2); }

        /* ===== CHANGE SUMMARY ===== */
        .change-summary-header {
            padding: 10px 14px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            font-weight: 700;
            font-size: 0.8rem;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .change-list {
            flex: 1;
            overflow-y: auto;
            padding: 6px 0;
        }

        .change-date-group {
            padding: 4px 14px;
            font-size: 0.6rem;
            font-weight: 700;
            color: #94a3b8;
            text-transform: uppercase;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            position: sticky;
            top: 0;
            background: rgba(20, 20, 40, 0.98);
            z-index: 5;
        }

        .change-entry {
            display: flex;
            align-items: flex-start;
            gap: 6px;
            padding: 4px 14px;
            font-size: 0.58rem;
            border-bottom: 1px solid rgba(255,255,255,0.02);
        }
        .change-entry:hover { background: rgba(255,255,255,0.03); }

        .change-icon-add { color: #10b981; font-weight: 700; font-size: 0.7rem; }
        .change-icon-remove { color: #ef4444; font-weight: 700; font-size: 0.7rem; }

        .change-detail { flex: 1; color: #cbd5e1; line-height: 1.4; }

        .change-undo {
            color: rgba(255,255,255,0.25);
            cursor: pointer;
            font-size: 0.5rem;
            flex-shrink: 0;
        }
        .change-undo:hover { color: #f59e0b; }

        .change-summary-footer {
            padding: 8px 14px;
            border-top: 1px solid rgba(255,255,255,0.08);
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }

        .change-summary-footer button {
            flex: 1;
            padding: 5px;
            font-size: 0.6rem;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        /* ===== SELECTION SCREEN v2 ===== */
        .selection-screen {
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .selection-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 24px;
        }

        .selection-day-group {
            margin-bottom: 24px;
        }

        .selection-day-header {
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            padding: 6px 0;
            border-bottom: 2px solid rgba(255,255,255,0.1);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .selection-section {
            margin-bottom: 12px;
        }

        .selection-section-title {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
        }
        .selection-section-title:hover { filter: brightness(1.15); }

        .sel-event-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px 4px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: background 0.1s;
        }
        .sel-event-row:hover { background: rgba(255,255,255,0.04); }

        .sel-cb {
            width: 14px; height: 14px;
            border: 2px solid rgba(255,255,255,0.25);
            border-radius: 3px;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
            transition: all 0.15s;
            font-size: 9px;
        }
        .sel-cb.checked { background: #3b82f6; border-color: #3b82f6; color: white; }

        .sel-crew-preview {
            font-size: 0.6rem;
            color: rgba(255,255,255,0.3);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px;
        }

        .na-category-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 4px 20px;
        }

        .na-cat-chip {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.5);
            transition: all 0.15s;
        }
        .na-cat-chip.selected {
            border-color: #ef4444;
            color: #fca5a5;
            background: rgba(239,68,68,0.15);
        }

        /* ===== QUICK SELECT BUTTONS ===== */
        .quick-select-bar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .quick-select-btn {
            padding: 5px 14px;
            font-size: 0.65rem;
            font-weight: 700;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.15s;
            border: 1.5px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.6);
            background: transparent;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .quick-select-btn:hover { filter: brightness(1.2); }

        .quick-select-btn.active-a {
            border-color: #a855f7;
            color: #d8b4fe;
            background: rgba(168,85,247,0.15);
        }
        .quick-select-btn.active-b {
            border-color: #f97316;
            color: #fed7aa;
            background: rgba(249,115,22,0.15);
        }
        .quick-select-btn.active-staff {
            border-color: #22c55e;
            color: #bbf7d0;
            background: rgba(34,197,94,0.15);
        }

        .selection-separator {
            font-size: 0.65rem;
            font-weight: 700;
            color: rgba(255,255,255,0.25);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: 12px 0 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .selection-separator::before,
        .selection-separator::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255,255,255,0.06);
        }

        /* Class-group sub-section colors */
        .class-group-a { border-left-color: #a855f7 !important; }
        .class-group-b { border-left-color: #f97316 !important; }
        .class-group-staff { border-left-color: #22c55e !important; }
        .class-group-other { border-left-color: #64748b !important; }

        /* ===== MISC ===== */
        .hour-line {
            position: absolute;
            top: 0; bottom: 0;
            width: 1px;
            background: rgba(255,255,255,0.05);
            pointer-events: none;
            z-index: 1;
        }

        .loading-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            gap: 16px;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 32px; height: 32px;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .filter-btn {
            padding: 4px 12px;
            font-size: 0.65rem;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.6);
            background: transparent;
        }
        .filter-btn:hover { border-color: rgba(255,255,255,0.3); color: white; }

        .day-tabs {
            display: flex;
            gap: 2px;
            overflow-x: auto;
        }

        .day-tab {
            padding: 3px 8px;
            font-size: 0.55rem;
            font-weight: 600;
            border-radius: 3px 3px 0 0;
            cursor: pointer;
            color: rgba(255,255,255,0.35);
            white-space: nowrap;
            transition: all 0.15s;
        }
        .day-tab:hover { color: rgba(255,255,255,0.6); background: rgba(255,255,255,0.04); }
        .day-tab.today { color: #3b82f6; background: rgba(59,130,246,0.08); }

        .empty-day {
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.12);
            font-size: 0.7rem;
            padding: 40px;
        }

        .saved-indicator {
            font-size: 0.5rem;
            color: #10b981;
            margin-left: 8px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .saved-indicator.show { opacity: 1; }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.03); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 3px; }
        ::-webkit-scrollbar-corner { background: #1a1a2e; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;

        // ==========================================
        // CONSTANTS
        // ==========================================

        const API_URL = 'https://script.google.com/macros/s/AKfycbyZNyrLxkW2vjbq8xpii43rWzYkkDvJTQ_KQCGMyErPZKqssL0XiA_UknwxOJ_XGzAt/exec';
        const STORAGE_KEY = 'tps-scheduler-state';

        const TIMELINE_START = 6 * 60;
        const TIMELINE_END   = 18 * 60;
        const TIMELINE_RANGE = TIMELINE_END - TIMELINE_START;
        const DAY_COL_WIDTH  = 750;

        const SECTION_ORDER = ['Flying', 'Ground', 'NA'];

        // Color scheme matching source spreadsheet
        const CATEGORY_COLORS = {
            'FTC-A':            { bg: '#7c3aed', text: '#f3e8ff' },  // purple
            'FTC-B':            { bg: '#ea580c', text: '#fff7ed' },  // orange
            'STC-A':            { bg: '#9333ea', text: '#fae8ff' },  // purple variant
            'STC-B':            { bg: '#f97316', text: '#ffedd5' },  // orange variant
            'Staff IP':         { bg: '#16a34a', text: '#dcfce7' },  // green
            'Staff IFTE/ICSO':  { bg: '#4338ca', text: '#e0e7ff' },  // indigo
            'Staff STC':        { bg: '#2563eb', text: '#dbeafe' },  // blue
            'Attached/Support': { bg: '#64748b', text: '#f1f5f9' },  // slate
        };

        const DEFAULT_CHIP = { bg: '#475569', text: '#e2e8f0' };

        // ==========================================
        // UTILITIES
        // ==========================================

        const timeToMinutes = (str) => {
            if (!str) return null;
            const m = str.match(/(\d{1,2}):(\d{2})/);
            return m ? parseInt(m[1]) * 60 + parseInt(m[2]) : null;
        };

        const minutesToTime = (mins) => {
            const h = Math.floor(mins / 60);
            const m = Math.floor(mins % 60);
            return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
        };

        const timePct = (mins) => Math.max(0, Math.min(100, ((mins - TIMELINE_START) / TIMELINE_RANGE) * 100));

        let _eid = 0;
        const mkId = () => `evt-${++_eid}`;

        const evStart = (ev) => timeToMinutes(ev.startTime);
        const evEnd = (ev) => {
            const e = timeToMinutes(ev.endTime);
            const s = timeToMinutes(ev.startTime);
            return e || (s ? s + 60 : TIMELINE_END);
        };

        // Effective visual end accounting for min-width:140px expansion
        const visualEnd = (ev) => {
            const s = evStart(ev);
            const e = evEnd(ev);
            if (s == null) return e;
            const dur = e - s;
            const widthPct = (dur / TIMELINE_RANGE) * 100;
            const cardPx = (widthPct / 100) * DAY_COL_WIDTH;
            if (cardPx >= 140) return e;
            // Card is expanded to 140px â€” compute what end time that corresponds to
            const expandedPct = (140 / DAY_COL_WIDTH) * 100;
            const expandedDur = (expandedPct / 100) * TIMELINE_RANGE;
            return s + expandedDur;
        };

        const overlap = (a, b) => {
            const aS = evStart(a), aE = evEnd(a), bS = evStart(b), bE = evEnd(b);
            if (aS == null || bS == null) return false;
            return aS < bE && bS < aE;
        };

        const fmtDate = (iso) => {
            const [y,m,d] = iso.split('-').map(Number);
            const dt = new Date(Date.UTC(y, m-1, d));
            const wd = dt.toLocaleDateString('en-US', { weekday: 'short', timeZone: 'UTC' });
            const mo = dt.toLocaleDateString('en-US', { month: 'short', timeZone: 'UTC' });
            return { weekday: wd, day: d, month: mo, full: `${wd} ${d} ${mo}` };
        };

        const personCat = (name, roster) => {
            for (const [cat, members] of Object.entries(roster)) {
                if (members.includes(name)) return cat;
            }
            return null;
        };

        const chipColor = (name, roster) => {
            const cat = personCat(name, roster);
            return (cat && CATEGORY_COLORS[cat]) || DEFAULT_CHIP;
        };

        // Filter out strings that are notes, not names
        const isValidName = (str) => {
            if (!str || typeof str !== 'string') return false;
            const t = str.trim();
            if (!t || t.length > 25) return false;
            if (t === 'FALSE' || t === 'TRUE') return false;
            if (t.split(/\s+/).length > 4) return false;
            return true;
        };

        // ==========================================
        // DATA TRANSFORMATION
        // ==========================================

        const transformSheetReturn = (sheet, date) => {
            const events = [];
            if (!sheet || !sheet.schedule) return events;
            sheet.schedule.forEach(item => {
                const sec = item.section;
                const personnel = (item.personnel || []).filter(isValidName).map(p => p.trim());
                if (sec === 'Supervision' || sec === 'Academics') {
                    events.push({
                        id: mkId(), section: sec, date,
                        model: null,
                        eventName: sec === 'Supervision' ? item.details.duty : item.details.eventName,
                        startTime: item.details.startTime || item.time,
                        endTime: item.details.endTime || null,
                        etd: null, eta: null,
                        personnel: [...personnel],
                        originalPersonnel: [...personnel],
                        notes: null, readonly: true,
                    });
                } else if (sec === 'Flying') {
                    events.push({
                        id: mkId(), section: 'Flying', date,
                        model: (item.details.model || '').trim(),
                        eventName: item.details.eventName || '',
                        startTime: item.details.briefTime || item.time,
                        endTime: item.details.debriefEnd || null,
                        etd: item.details.etd || null,
                        eta: item.details.eta || null,
                        personnel: [...personnel],
                        originalPersonnel: [...personnel],
                        notes: item.details.notes === 'FALSE' ? null : item.details.notes,
                        readonly: false,
                    });
                } else if (sec === 'Ground') {
                    events.push({
                        id: mkId(), section: 'Ground', date,
                        model: null,
                        eventName: item.details.eventName || '',
                        startTime: item.details.startTime || item.time,
                        endTime: item.details.endTime || null,
                        etd: null, eta: null,
                        personnel: [...personnel],
                        originalPersonnel: [...personnel],
                        notes: item.details.notes, readonly: false,
                    });
                } else if (sec === 'NA') {
                    events.push({
                        id: mkId(), section: 'NA', date,
                        model: null,
                        eventName: item.details.reason || 'NA',
                        startTime: item.details.startTime || item.time,
                        endTime: item.details.endTime || null,
                        etd: null, eta: null,
                        personnel: [...personnel],
                        originalPersonnel: [...personnel],
                        notes: null, readonly: false,
                    });
                }
            });
            return events;
        };

        const transformBatchData = (batchJson, roster) => {
            const all = [];
            if (!batchJson || !batchJson.days) return all;

            batchJson.days.forEach(dayData => {
                const date = dayData.isoDate;
                const raw = dayData.data;

                if (raw.flying) {
                    raw.flying.forEach(row => {
                        const briefTime = row[1];
                        const eventName = row[5];
                        if (!briefTime || !eventName || eventName === 'Event') return;
                        const crew = row.slice(6, 15).filter(isValidName).map(c => c.trim());
                        if (crew.length === 0) return;
                        all.push({
                            id: mkId(), section: 'Flying', date,
                            model: (row[0] || '').trim(),
                            eventName,
                            startTime: briefTime,
                            endTime: row[4],
                            etd: row[2], eta: row[3],
                            personnel: crew,
                            originalPersonnel: [...crew],
                            notes: (row[15] && row[15] !== 'FALSE') ? row[15] : null,
                            readonly: false,
                        });
                    });
                }

                if (raw.ground) {
                    raw.ground.forEach(row => {
                        const evName = row[0];
                        const start = row[1];
                        if (!evName || !start || evName === 'Events') return;
                        const people = row.slice(3, 10).filter(isValidName).map(p => p.trim());
                        all.push({
                            id: mkId(), section: 'Ground', date,
                            model: null, eventName: evName,
                            startTime: start, endTime: row[2],
                            etd: null, eta: null,
                            personnel: people,
                            originalPersonnel: [...people],
                            notes: (row[10] && row[10] !== 'FALSE') ? row[10] : null,
                            readonly: false,
                        });
                    });
                }

                if (raw.na) {
                    raw.na.forEach(row => {
                        const reason = row[0];
                        const start = row[1];
                        if (!reason || !start || reason === 'Reason') return;
                        const people = row.slice(3).filter(isValidName).map(p => p.trim());
                        all.push({
                            id: mkId(), section: 'NA', date,
                            model: null, eventName: reason,
                            startTime: start, endTime: row[2],
                            etd: null, eta: null,
                            personnel: people,
                            originalPersonnel: [...people],
                            notes: null, readonly: false,
                        });
                    });
                }

                if (raw.supervision) {
                    raw.supervision.forEach(row => {
                        const duty = row[0];
                        if (!duty || duty === 'Supervision' || !duty.trim()) return;
                        for (let i = 1; i < row.length - 2; i += 3) {
                            const poc = row[i];
                            if (poc && poc.trim() && isValidName(poc)) {
                                all.push({
                                    id: mkId(), section: 'Supervision', date,
                                    model: null, eventName: duty.trim(),
                                    startTime: row[i+1], endTime: row[i+2],
                                    etd: null, eta: null,
                                    personnel: [poc.trim()],
                                    originalPersonnel: [poc.trim()],
                                    notes: null, readonly: true,
                                });
                            }
                        }
                    });
                }

                if (raw.academics) {
                    const gm = { 'Alpha FTC':'FTC-A','Alpha STC':'STC-A','Bravo FTC':'FTC-B','Bravo STC':'STC-B','IP':'Staff IP','Staff STC':'Staff STC','IFTE/IWSO':'Staff IFTE/ICSO' };
                    raw.academics.forEach(row => {
                        const group = row[0], start = row[1];
                        if (!group || !start || group === 'Academics') return;
                        const cat = gm[group.trim()];
                        const people = (cat && roster[cat]) || [];
                        all.push({
                            id: mkId(), section: 'Academics', date,
                            model: null, eventName: `${group} Academics`,
                            startTime: start, endTime: row[2],
                            etd: null, eta: null,
                            personnel: [...people],
                            originalPersonnel: [...people],
                            notes: null, readonly: true,
                        });
                    });
                }
            });

            return all;
        };

        // ==========================================
        // DUPLICATE EVENT MERGING
        // ==========================================

        // Returns true if name appears in any staff roster category
        const isStaff = (name, roster) => {
            if (!name || !roster) return false;
            const staffCategories = ['Staff IP', 'Staff IFTE/ICSO', 'Staff STC', 'Attached/Support'];
            return staffCategories.some(cat =>
                (roster[cat] || []).some(rName => rName.trim() === name.trim())
            );
        };

        const mergeDuplicateEvents = (events, roster) => {
            if (!events || events.length === 0) return events;

            const mergeableEvents = [];

            events.forEach(ev => {
                if (ev.readonly || ev.section === 'NA' || ev.section === 'Supervision' || ev.section === 'Academics') {
                    // pass-through: not mergeable
                } else {
                    mergeableEvents.push(ev);
                }
            });

            // Phase 1: Group by base key WITHOUT personnel[0]
            const baseGroups = new Map();

            mergeableEvents.forEach(ev => {
                let key;
                if (ev.section === 'Flying') {
                    key = [ev.date, ev.section, (ev.model || '').trim(), (ev.eventName || '').trim(),
                        (ev.startTime || ''), (ev.endTime || ''), (ev.etd || ''), (ev.eta || '')].join('||');
                } else {
                    key = [ev.date, ev.section, (ev.eventName || '').trim(),
                        (ev.startTime || ''), (ev.endTime || '')].join('||');
                }
                if (!baseGroups.has(key)) baseGroups.set(key, []);
                baseGroups.get(key).push(ev);
            });

            // Phase 2: Within each base group, check distinct staff leads to decide merge strategy
            const mergedById = new Map();
            const removedIds = new Set();

            // Helper: get the staff instructor lead from an event (personnel[0] if they are staff)
            const getStaffLead = (ev) => {
                if (!ev.personnel || ev.personnel.length === 0) return null;
                const first = ev.personnel[0];
                return isStaff(first, roster) ? first : null;
            };

            // Helper: merge a group of events into one, updating mergedById and removedIds
            const mergeGroup = (group) => {
                if (group.length <= 1) return;

                // Pick primary: prefer an event whose personnel[0] is staff (instructor lead)
                let primaryIdx = 0;
                for (let i = 0; i < group.length; i++) {
                    if (getStaffLead(group[i])) { primaryIdx = i; break; }
                }
                const primary = group[primaryIdx];

                // Build combined personnel with staff lead first
                const staffLead = getStaffLead(primary);
                const seen = new Set();
                const combinedPersonnel = [];
                if (staffLead) {
                    combinedPersonnel.push(staffLead);
                    seen.add(staffLead);
                }
                // Add primary's remaining personnel
                (primary.personnel || []).forEach(person => {
                    if (!seen.has(person)) { combinedPersonnel.push(person); seen.add(person); }
                });
                // Add all other events' personnel
                group.forEach((ev, i) => {
                    if (i === primaryIdx) return;
                    (ev.personnel || []).forEach(person => {
                        if (!seen.has(person)) { combinedPersonnel.push(person); seen.add(person); }
                    });
                });

                // Merge notes
                const noteSet = new Set();
                group.forEach(ev => { if (ev.notes && ev.notes.trim()) noteSet.add(ev.notes.trim()); });
                const mergedNotes = noteSet.size > 0 ? [...noteSet].join('; ') : primary.notes;

                // Merge Flying-specific fields
                let mergedEtd = primary.etd, mergedEta = primary.eta, mergedEndTime = primary.endTime;
                if (primary.section === 'Flying') {
                    group.forEach(ev => {
                        if (!mergedEtd && ev.etd) mergedEtd = ev.etd;
                        if (!mergedEta && ev.eta) mergedEta = ev.eta;
                        if (!mergedEndTime && ev.endTime) mergedEndTime = ev.endTime;
                    });
                }

                mergedById.set(primary.id, {
                    ...primary, etd: mergedEtd, eta: mergedEta, endTime: mergedEndTime,
                    personnel: combinedPersonnel, originalPersonnel: [...combinedPersonnel], notes: mergedNotes,
                });
                group.forEach((ev, i) => { if (i !== primaryIdx) removedIds.add(ev.id); });
            };

            baseGroups.forEach((group) => {
                if (group.length <= 1) return;

                // Find distinct staff leads in this base group
                const staffLeads = new Set();
                group.forEach(ev => {
                    const sl = getStaffLead(ev);
                    if (sl) staffLeads.add(sl);
                });

                if (staffLeads.size <= 1) {
                    // 0 or 1 distinct instructor leads: merge everything together
                    mergeGroup(group);
                } else {
                    // 2+ distinct instructor leads: sub-group by staff lead
                    // Events with no staff lead attach to the first sub-group that has one,
                    // or form their own group if none do (shouldn't happen since staffLeads.size >= 2)
                    const subGroups = new Map(); // staffLead -> events
                    const noLeadEvents = [];

                    group.forEach(ev => {
                        const sl = getStaffLead(ev);
                        if (sl) {
                            if (!subGroups.has(sl)) subGroups.set(sl, []);
                            subGroups.get(sl).push(ev);
                        } else {
                            noLeadEvents.push(ev);
                        }
                    });

                    // Distribute no-lead events into existing sub-groups
                    // Each no-lead event goes to the first sub-group (arbitrary but deterministic)
                    if (noLeadEvents.length > 0 && subGroups.size > 0) {
                        const firstKey = subGroups.keys().next().value;
                        noLeadEvents.forEach(ev => subGroups.get(firstKey).push(ev));
                    }

                    subGroups.forEach((subGroup) => {
                        mergeGroup(subGroup);
                    });
                }
            });

            // Rebuild result preserving original order, substituting merged events, dropping removed
            const result = [];
            events.forEach(ev => {
                if (removedIds.has(ev.id)) return;
                if (mergedById.has(ev.id)) result.push(mergedById.get(ev.id));
                else result.push(ev);
            });
            return result;
        };

        // ==========================================
        // CONFLICT DETECTION (with detail info)
        // ==========================================

        const detectConflicts = (allEvents) => {
            // Map: person||date -> [events]
            const pdMap = {};
            allEvents.forEach(ev => {
                ev.personnel.forEach(person => {
                    const k = `${person}||${ev.date}`;
                    if (!pdMap[k]) pdMap[k] = [];
                    pdMap[k].push(ev);
                });
            });

            // Map<eventId, Map<personName, [{eventName, model, section, startTime, endTime}]>>
            const conflicts = new Map();

            Object.values(pdMap).forEach(evList => {
                if (evList.length < 2) return;
                for (let i = 0; i < evList.length; i++) {
                    for (let j = i + 1; j < evList.length; j++) {
                        if (!overlap(evList[i], evList[j])) continue;
                        const common = evList[i].personnel.filter(p => evList[j].personnel.includes(p));
                        common.forEach(person => {
                            // Record on event i
                            if (!conflicts.has(evList[i].id)) conflicts.set(evList[i].id, new Map());
                            const ci = conflicts.get(evList[i].id);
                            if (!ci.has(person)) ci.set(person, []);
                            ci.get(person).push({
                                eventName: evList[j].eventName, model: evList[j].model,
                                section: evList[j].section,
                                startTime: evList[j].startTime, endTime: evList[j].endTime,
                            });
                            // Record on event j
                            if (!conflicts.has(evList[j].id)) conflicts.set(evList[j].id, new Map());
                            const cj = conflicts.get(evList[j].id);
                            if (!cj.has(person)) cj.set(person, []);
                            cj.get(person).push({
                                eventName: evList[i].eventName, model: evList[i].model,
                                section: evList[i].section,
                                startTime: evList[i].startTime, endTime: evList[i].endTime,
                            });
                        });
                    }
                }
            });

            return conflicts;
        };

        const getConflictText = (eventId, person, conflicts) => {
            const ec = conflicts.get(eventId);
            if (!ec) return null;
            const pc = ec.get(person);
            if (!pc || pc.length === 0) return null;
            return pc.map(c => {
                const m = c.model ? `${c.model} ` : '';
                return `${m}${c.eventName} (${c.startTime}-${c.endTime || '??'})`;
            }).join('; ');
        };

        const hasConflict = (eventId, person, conflicts) => {
            const ec = conflicts.get(eventId);
            return ec && ec.has(person);
        };

        const eventConflictCount = (eventId, conflicts) => {
            const ec = conflicts.get(eventId);
            return ec ? ec.size : 0;
        };

        // ==========================================
        // NET CHANGE COMPUTATION
        // ==========================================

        function computeNetChanges(changes) {
            if (!changes || changes.length === 0) return [];

            const netMap = new Map();
            changes.forEach((ch, idx) => {
                const key = `${ch.person}||${ch.eventId}`;
                if (!netMap.has(key)) {
                    netMap.set(key, {
                        net: 0, indices: [], person: ch.person, eventId: ch.eventId,
                        eventMeta: { eventId: ch.eventId, eventName: ch.eventName, eventModel: ch.eventModel,
                            eventTime: ch.eventTime, eventSection: ch.eventSection, date: ch.date },
                    });
                }
                const entry = netMap.get(key);
                entry.net += (ch.type === 'add' ? 1 : -1);
                entry.indices.push(idx);
            });

            const personEffects = new Map();
            for (const [, entry] of netMap) {
                if (!personEffects.has(entry.person)) {
                    personEffects.set(entry.person, { adds: [], removes: [], zeroIndices: [] });
                }
                const pe = personEffects.get(entry.person);
                if (entry.net > 0) pe.adds.push(entry);
                else if (entry.net < 0) pe.removes.push(entry);
                else pe.zeroIndices.push(...entry.indices);
            }

            const rawInstructions = [];
            for (const [person, pe] of personEffects) {
                pe.adds.sort((a, b) => Math.min(...a.indices) - Math.min(...b.indices));
                pe.removes.sort((a, b) => Math.min(...a.indices) - Math.min(...b.indices));
                const numMoves = Math.min(pe.adds.length, pe.removes.length);

                for (let i = 0; i < numMoves; i++) {
                    const rem = pe.removes[i], add = pe.adds[i];
                    const allIndices = [...rem.indices, ...add.indices];
                    if (numMoves === 1 && pe.adds.length === 1 && pe.removes.length === 1) {
                        allIndices.push(...pe.zeroIndices);
                    }
                    rawInstructions.push({ type: 'move', person, date: rem.eventMeta.date,
                        source: rem.eventMeta, target: add.eventMeta,
                        rawIndices: allIndices, firstIndex: Math.min(...allIndices) });
                }
                if (numMoves > 1 && pe.zeroIndices.length > 0) {
                    rawInstructions[rawInstructions.length - numMoves].rawIndices.push(...pe.zeroIndices);
                }
                for (let i = numMoves; i < pe.adds.length; i++) {
                    const add = pe.adds[i];
                    rawInstructions.push({ type: 'add', person, date: add.eventMeta.date,
                        source: null, target: add.eventMeta,
                        rawIndices: [...add.indices], firstIndex: Math.min(...add.indices) });
                }
                for (let i = numMoves; i < pe.removes.length; i++) {
                    const rem = pe.removes[i];
                    rawInstructions.push({ type: 'remove', person, date: rem.eventMeta.date,
                        source: rem.eventMeta, target: null,
                        rawIndices: [...rem.indices], firstIndex: Math.min(...rem.indices) });
                }
            }

            const groupMap = new Map();
            rawInstructions.forEach(inst => {
                let groupKey;
                if (inst.type === 'move') groupKey = `move||${inst.source.eventId}||${inst.target.eventId}`;
                else if (inst.type === 'add') groupKey = `add||${inst.target.eventId}`;
                else groupKey = `remove||${inst.source.eventId}`;

                if (!groupMap.has(groupKey)) {
                    groupMap.set(groupKey, { type: inst.type, persons: [], date: inst.date,
                        source: inst.source, target: inst.target, rawIndices: [], firstIndex: inst.firstIndex });
                }
                const group = groupMap.get(groupKey);
                group.persons.push(inst.person);
                group.rawIndices.push(...inst.rawIndices);
                group.firstIndex = Math.min(group.firstIndex, inst.firstIndex);
            });

            const result = Array.from(groupMap.values());
            result.sort((a, b) => a.date !== b.date ? a.date.localeCompare(b.date) : a.firstIndex - b.firstIndex);
            return result;
        }

        // ==========================================
        // LANE ASSIGNMENT (dynamic heights)
        // ==========================================

        const estimateHeight = (ev) => {
            let h = 18; // title bar
            if (ev.section === 'Flying' && ev.etd && ev.eta) h += 14;
            const crewCount = Math.max(1, ev.personnel.length + 1); // +1 for add chip

            // Width-aware: compute card pixel width from time span
            const sMin = evStart(ev);
            const eMin = evEnd(ev);
            const dur = (eMin - sMin) || 60;
            const widthPct = (dur / TIMELINE_RANGE) * 100;
            const cardPxWidth = Math.max(140, (widthPct / 100) * DAY_COL_WIDTH);

            // Estimate chips per row based on actual card width
            const chipAreaWidth = cardPxWidth - 14; // padding
            const avgChipWidth = 78;
            const chipsPerRow = Math.max(1, Math.floor(chipAreaWidth / avgChipWidth));

            const rows = Math.ceil(crewCount / chipsPerRow);
            h += rows * 20 + 6;
            return Math.max(h, 40);
        };

        const buildLayout = (events) => {
            if (events.length === 0) return { evMap: {}, total: 0 };

            const sorted = [...events].sort((a, b) => (evStart(a) || 0) - (evStart(b) || 0));
            const lanes = [];
            const laneOf = {};

            sorted.forEach(ev => {
                let placed = false;
                for (let i = 0; i < lanes.length; i++) {
                    const last = lanes[i][lanes[i].length - 1];
                    if ((evStart(ev) || 0) >= (visualEnd(last) || 0)) {
                        lanes[i].push(ev);
                        laneOf[ev.id] = i;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    lanes.push([ev]);
                    laneOf[ev.id] = lanes.length - 1;
                }
            });

            // Lane heights
            const laneH = lanes.map(lane => Math.max(...lane.map(estimateHeight)));
            const laneTop = [];
            let cum = 0;
            laneH.forEach((h, i) => { laneTop[i] = cum; cum += h + 3; });

            const evMap = {};
            events.forEach(ev => {
                const li = laneOf[ev.id] ?? 0;
                evMap[ev.id] = { top: laneTop[li] || 0, height: estimateHeight(ev) };
            });

            return { evMap, total: cum };
        };

        // ==========================================
        // SAMPLE DATA
        // ==========================================

        const SAMPLE_ROSTER = {"FTC-B":["Arnold, C","Baum, J","Bean, P","Cagliano, C","Dockum, T","Ehler, A","Ferrer, J","Harms, J *","Heater, M","Juedeman, D","Kalampoukis","Larsen, R","Marshall, R","Olvera, J","Pilling, H","Reed, C","Roberts, J","Rogers, J","Slaughter, J","Stiscia, I","Toth, E","Williams, J","Wilson, R","Wooden, J"],"STC-B":["Baxter, C","Beck, S","Coolican, H","McIlhenny, M","Newland, A","Rocker, C"],"FTC-A":["Bertke, F","Bradley, J","Clements, J *","Dobbs, D","Ghesquiere, L","Graham, J","Knoerr, S","Leaf, A","Martinez, P","Morrison, J","Novack, R","Nyang, B","Olson, C","Oren, E","Orfitelli, N","Oshea, P","Pessolano, C","Peterson, R","Pope, D","Rogers, H","Root, S","Ryan, J","Sternat, N","Umland, M"],"STC-A":["Barbosa, T","Barone, R","Bartkowiak, R","Butcher, M","Doyle, D","Holmes, C","Konnath, M","Pitre, S","Quick, L","Sargent, R"],"Staff IP":["Adair, T","Ames","Borek","Coleman","Duede","Fields","Fitzgerald","Gotwald","Gray, W","Heary","Hebmann","Hickernell","Hutcheson","Karlen","Lovell","Major, K","Montes","Patel","Payne","Sick","Siddiqui","Smith, K","Strafaccia","Vantiger","White, C"],"Staff IFTE/ICSO":["Agbeyibor, R","Aronoff, R","Baltunis","Baxley, C","Bernstein","Dawson, D","Echegaray","Erb, R","Gahan","Hamidani","Hinojos","Kemper","Kinard","McCafferty","Miller, E","Peterson, W","Ricci","Sanders","Sisneroz, M","Tegtmeier","Vanhoy","Wenner, A"],"Staff STC":["Dauk, K","Farmer, M","Heinz, D","Lowry, W","Neff, B","Palski, M","Post, T","Reis, C","Ross, J","Ruchlin, B","Salerno, C","Sands, T","Saunders, M","Walter, S"],"Attached/Support":["Adams, D","Alora","Brooks","Buckwalter","Digiacomo","Downing","Elledge","Flynn","Forystek","Freeborn","Giffen","Gilliland","Graham","Hammond","Hayes","Janjua","Kern, S","Killingsworth","Lee, C","Marcus","Peter, D","Peterson, J","Pinedo","Praiswater","Russell","Shick","Steigerwald","Suhr","Tanner, R","Valentini","Vorgert, S","Webb","Williford","Wright"]};

        const SAMPLE_DATES = ["2026-02-03","2026-02-04","2026-02-05","2026-02-06","2026-02-09"];

        const SAMPLE_SHEET = {
            schedule: [
                { section:"Supervision", time:"07:15", details:{ duty:"SOF", startTime:"07:15", endTime:"12:00" }, personnel:["Coleman"] },
                { section:"Supervision", time:"06:30", details:{ duty:"OS", startTime:"06:30", endTime:"12:45" }, personnel:["Fitzgerald"] },
                { section:"Supervision", time:"12:45", details:{ duty:"OS", startTime:"12:45", endTime:"17:00" }, personnel:["Borek"] },
                { section:"Supervision", time:"06:30", details:{ duty:"ODO", startTime:"06:30", endTime:"16:00" }, personnel:["Bernstein"] },
                { section:"Flying", time:"08:15", details:{ model:"F-16", eventName:"STRUCTURES EE (FQ7230)", briefTime:"08:15", etd:"10:45", eta:"12:15", debriefEnd:"13:15", notes:"FALSE" }, personnel:["Larsen, R","Buckwalter"] },
                { section:"Flying", time:"08:45", details:{ model:"F-16", eventName:"SENSORS DEMO (SY6130)", briefTime:"08:45", etd:"10:45", eta:"12:15", debriefEnd:"13:15", notes:"FALSE" }, personnel:["Juedeman, D","Hickernell"] },
                { section:"Flying", time:"07:00", details:{ model:"C-12", eventName:"MSN QUAL", briefTime:"07:00", etd:"11:00", eta:"13:00", debriefEnd:"14:00", notes:"FALSE" }, personnel:["Ames","Major, K"] },
                { section:"Flying", time:"09:30", details:{ model:"T-38", eventName:"LOW L/D P/S CHASE", briefTime:"09:30", etd:"11:30", eta:"12:30", debriefEnd:"13:30", notes:"FALSE" }, personnel:["Heary","Reed, C"] },
                { section:"Flying", time:"09:30", details:{ model:"T-38", eventName:"LOW L/D P/S CHASE", briefTime:"09:30", etd:"11:30", eta:"12:30", debriefEnd:"13:30", notes:"FALSE" }, personnel:["Vantiger","Roberts, J"] },
                { section:"Flying", time:"13:30", details:{ model:"T-38", eventName:"MSN QUAL FORM UPG", briefTime:"13:30", etd:"15:30", eta:"16:30", debriefEnd:"17:30", notes:"FALSE" }, personnel:["Digiacomo","Payne"] },
                { section:"Flying", time:"09:00", details:{ model:"X-62A", eventName:"VISTA UPG", briefTime:"09:00", etd:"11:00", eta:"12:30", debriefEnd:"13:30", notes:"FALSE" }, personnel:["Gray, W","Janjua"] },
                { section:"Flying", time:"07:00", details:{ model:"EXTRA", eventName:"QUAL", briefTime:"07:00", etd:"08:00", eta:"09:00", debriefEnd:"11:00", notes:"FALSE" }, personnel:["Marshall, R"] },
                { section:"Ground", time:"15:00", details:{ eventName:"Heavy Acft Sim Evals MIB", startTime:"15:00", endTime:"17:00", notes:null }, personnel:["Borek"] },
                { section:"Ground", time:"10:00", details:{ eventName:"CR TC Primer CR A", startTime:"10:00", endTime:"13:00", notes:null }, personnel:["Peterson, J","Duede"] },
                { section:"Ground", time:"07:30", details:{ eventName:"NASA Meeting", startTime:"07:30", endTime:"09:00", notes:null }, personnel:["Peterson, J","Kemper","Duede","Ricci"] },
                { section:"Ground", time:"08:00", details:{ eventName:"PIO SIM (FS Sim A)", startTime:"08:00", endTime:"09:00", notes:null }, personnel:["McCafferty","Toth, E","Arnold, C"] },
                { section:"Ground", time:"09:00", details:{ eventName:"PIO SIM (FS Sim B)", startTime:"09:00", endTime:"10:00", notes:null }, personnel:["Slaughter, J","Ehler, A"] },
                { section:"NA", time:"14:00", details:{ reason:"Master Scheduling Mtg", startTime:"14:00", endTime:"15:00" }, personnel:["Vantiger","Montes"] },
                { section:"NA", time:"09:00", details:{ reason:"TPS Staff Mtg", startTime:"09:00", endTime:"10:30" }, personnel:["Vantiger","Karlen","Vanhoy"] },
                { section:"NA", time:"09:00", details:{ reason:"IRC", startTime:"09:00", endTime:"12:30" }, personnel:["Gotwald"] },
                { section:"NA", time:"07:00", details:{ reason:"Water Survival", startTime:"07:00", endTime:"12:00" }, personnel:["Hamidani"] },
                { section:"NA", time:"13:00", details:{ reason:"MFLC Session", startTime:"13:00", endTime:"14:00" }, personnel:["Newland, A"] },
            ]
        };

        const buildSampleEvents = () => {
            const events = [];
            events.push(...transformSheetReturn(SAMPLE_SHEET, '2026-02-03'));
            events.push(...transformSheetReturn(SAMPLE_SHEET, '2026-02-04'));
            return mergeDuplicateEvents(events, SAMPLE_ROSTER);
        };

        // ==========================================
        // LOCAL STORAGE
        // ==========================================

        const saveState = (changes, selectedIds, naCats) => {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify({
                    changes,
                    selectedIds: [...selectedIds],
                    naCats: [...naCats],
                    savedAt: new Date().toISOString(),
                }));
            } catch (e) {}
        };

        const loadState = () => {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return null;
                const data = JSON.parse(raw);
                return {
                    changes: data.changes || [],
                    selectedIds: new Set(data.selectedIds || []),
                    naCats: new Set(data.naCats || []),
                    savedAt: data.savedAt,
                };
            } catch (e) { return null; }
        };

        const clearState = () => {
            try { localStorage.removeItem(STORAGE_KEY); } catch (e) {}
        };

        // ==========================================
        // COMPONENTS
        // ==========================================

        const LoadingScreen = ({ progress }) => (
            <div className="loading-screen">
                <div className="spinner" style={{ width: 40, height: 40, borderWidth: 4 }}></div>
                <div className="text-blue-400 font-bold tracking-widest uppercase text-xs">{progress || 'Loading...'}</div>
            </div>
        );

        // â”€â”€â”€ EVENT CLASSIFICATION â”€â”€â”€

        const STAFF_KEYWORDS = [
            'MSN QUAL', 'NVG QUAL', 'CHECKRIDE', 'CURRENCY', 'FERRY FLIGHT', 'FERRY',
            'CHASE', 'CADET', 'NAVY', 'HI AOA', 'UPGRADE', 'VISTA UPG', 'FORM UPG', 'UPG'
        ];

        const classifyEvent = (ev, roster) => {
            // 1. Check staff keywords against event name
            const name = (ev.eventName || '').toUpperCase();
            if (STAFF_KEYWORDS.some(kw => name.includes(kw))) return 'Staff';

            // 2. Count non-staff personnel by class
            const staffCats = new Set(['Staff IP', 'Staff IFTE/ICSO', 'Staff STC', 'Attached/Support']);
            let aCount = 0, bCount = 0;
            ev.personnel.forEach(p => {
                const cat = personCat(p, roster);
                if (!cat || staffCats.has(cat)) return; // skip staff/unknown
                if (cat === 'FTC-A' || cat === 'STC-A') aCount++;
                else if (cat === 'FTC-B' || cat === 'STC-B') bCount++;
            });

            if (aCount > 0 && aCount >= bCount) return 'A-Class';
            if (bCount > 0 && bCount > aCount) return 'B-Class';
            return 'Other';
        };

        const CLASS_COLORS = {
            'A-Class': { bg: 'rgba(168,85,247,0.08)', border: '#a855f7', text: '#d8b4fe', cssClass: 'class-group-a' },
            'B-Class': { bg: 'rgba(249,115,22,0.08)', border: '#f97316', text: '#fed7aa', cssClass: 'class-group-b' },
            'Staff':   { bg: 'rgba(34,197,94,0.08)',   border: '#22c55e', text: '#bbf7d0', cssClass: 'class-group-staff' },
            'Other':   { bg: 'rgba(100,116,139,0.08)', border: '#64748b', text: '#cbd5e1', cssClass: 'class-group-other' },
        };

        // â”€â”€â”€ SELECTION SCREEN (v3.1: role-based grouping, separate NA, quick-select) â”€â”€â”€

        const EventSelectionScreen = ({ allEvents, roster, dates, onContinue, initialSelected, initialNaCats }) => {
            const [selectedIds, setSelectedIds] = useState(initialSelected || new Set());
            const [naCats, setNaCats] = useState(initialNaCats || new Set());

            const secColors = {
                Flying: { bg: 'rgba(16,185,129,0.1)', border: '#10b981', text: '#6ee7b7' },
                Ground: { bg: 'rgba(245,158,11,0.1)', border: '#f59e0b', text: '#fde68a' },
                NA:     { bg: 'rgba(239,68,68,0.1)',   border: '#ef4444', text: '#fca5a5' },
            };

            // Classify all non-readonly, non-NA events and organize by date > class > section
            const { byDateClassified, classSets } = useMemo(() => {
                const map = {};
                const sets = { 'A-Class': new Set(), 'B-Class': new Set(), 'Staff': new Set(), 'Other': new Set() };

                dates.forEach(d => { map[d] = {}; });

                allEvents.forEach(ev => {
                    if (ev.readonly || ev.section === 'NA') return;
                    if (!map[ev.date]) return;

                    const cls = classifyEvent(ev, roster);
                    sets[cls].add(ev.id);

                    const key = `${cls}|${ev.section}`;
                    if (!map[ev.date][key]) map[ev.date][key] = [];
                    map[ev.date][key].push(ev);
                });

                // Sort events within each group by start time
                Object.values(map).forEach(groups => {
                    Object.values(groups).forEach(arr => {
                        arr.sort((a, b) => (evStart(a) || 0) - (evStart(b) || 0));
                    });
                });

                return { byDateClassified: map, classSets: sets };
            }, [allEvents, dates, roster]);

            // Categories that have NA events
            const naCategoriesAvailable = useMemo(() => {
                const cats = new Set();
                allEvents.forEach(ev => {
                    if (ev.section !== 'NA') return;
                    ev.personnel.forEach(p => {
                        const c = personCat(p, roster);
                        if (c) cats.add(c);
                    });
                });
                return [...cats].sort();
            }, [allEvents, roster]);

            // Toggle individual event
            const toggleEvent = (id) => {
                setSelectedIds(prev => {
                    const next = new Set(prev);
                    next.has(id) ? next.delete(id) : next.add(id);
                    return next;
                });
            };

            // Toggle all events in a specific group (class+section within a date)
            const toggleGroup = (evs) => {
                const ids = evs.map(e => e.id);
                const allSel = ids.every(id => selectedIds.has(id));
                setSelectedIds(prev => {
                    const next = new Set(prev);
                    ids.forEach(id => allSel ? next.delete(id) : next.add(id));
                    return next;
                });
            };

            // Quick-select: toggle ALL events in a class across ALL dates
            const toggleClass = (cls) => {
                const ids = classSets[cls];
                if (!ids || ids.size === 0) return;
                const allSel = [...ids].every(id => selectedIds.has(id));
                setSelectedIds(prev => {
                    const next = new Set(prev);
                    ids.forEach(id => allSel ? next.delete(id) : next.add(id));
                    return next;
                });
            };

            const toggleNaCat = (cat) => {
                setNaCats(prev => {
                    const next = new Set(prev);
                    next.has(cat) ? next.delete(cat) : next.add(cat);
                    return next;
                });
            };

            const selectAll = () => {
                const all = new Set();
                allEvents.forEach(ev => { if (!ev.readonly && ev.section !== 'NA') all.add(ev.id); });
                setSelectedIds(all);
                setNaCats(new Set(naCategoriesAvailable));
            };

            // Check if all events of a class are selected
            const isClassFullySelected = (cls) => {
                const ids = classSets[cls];
                return ids.size > 0 && [...ids].every(id => selectedIds.has(id));
            };

            const totalSelected = selectedIds.size + naCats.size;

            const classOrder = ['A-Class', 'B-Class', 'Staff', 'Other'];
            const sectionOrder = ['Flying', 'Ground'];

            return (
                <div className="selection-screen">
                    <div className="app-header">
                        <div>
                            <h1 className="text-lg font-bold text-white tracking-tight">TPS INTERACTIVE SCHEDULER</h1>
                            <p className="text-xs text-gray-500">Select events you are responsible for scheduling</p>
                        </div>
                        <div className="flex gap-3 items-center">
                            <button onClick={selectAll} className="filter-btn">Select All</button>
                            <button onClick={() => { setSelectedIds(new Set()); setNaCats(new Set()); }} className="filter-btn">Clear</button>
                            <button
                                onClick={() => onContinue(selectedIds, naCats)}
                                disabled={totalSelected === 0}
                                className="px-5 py-1.5 rounded-lg text-sm font-bold transition-colors"
                                style={{
                                    background: totalSelected > 0 ? '#2563eb' : '#374151',
                                    color: totalSelected > 0 ? 'white' : '#6b7280',
                                    cursor: totalSelected > 0 ? 'pointer' : 'not-allowed',
                                }}
                            >
                                Continue ({totalSelected})
                            </button>
                        </div>
                    </div>
                    <div className="selection-body">
                        <p className="text-xs text-gray-500 mb-2" style={{ lineHeight: 1.6 }}>
                            Conflict detection checks ALL events regardless of selection.
                        </p>

                        {/* NON-AVAILABILITY (separate from dates) */}
                        {naCategoriesAvailable.length > 0 && (
                            <div style={{ marginBottom: 20 }}>
                                <div className="selection-separator">NON-AVAILABILITY</div>
                                <p className="text-xs text-gray-600 mb-2" style={{ paddingLeft: 8 }}>
                                    Select crew categories to include in conflict tracking
                                </p>
                                <div className="na-category-grid">
                                    {naCategoriesAvailable.map(cat => {
                                        const catColor = CATEGORY_COLORS[cat];
                                        const isSelected = naCats.has(cat);
                                        return (
                                            <div
                                                key={cat}
                                                className={`na-cat-chip ${isSelected ? 'selected' : ''}`}
                                                onClick={() => toggleNaCat(cat)}
                                                style={isSelected && catColor ? {
                                                    borderColor: catColor.bg,
                                                    color: catColor.text,
                                                    background: catColor.bg + '30',
                                                } : undefined}
                                            >
                                                {cat}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        {/* QUICK SELECT */}
                        <div style={{ marginBottom: 20 }}>
                            <div className="selection-separator">QUICK SELECT</div>
                            <div className="quick-select-bar" style={{ padding: '4px 8px' }}>
                                {classOrder.filter(cls => classSets[cls].size > 0).map(cls => {
                                    const cc = CLASS_COLORS[cls];
                                    const active = isClassFullySelected(cls);
                                    const count = classSets[cls].size;
                                    const selectedCount = [...classSets[cls]].filter(id => selectedIds.has(id)).length;
                                    return (
                                        <button
                                            key={cls}
                                            className="quick-select-btn"
                                            onClick={() => toggleClass(cls)}
                                            style={active ? { borderColor: cc.border, color: cc.text, background: cc.bg } : undefined}
                                        >
                                            {cls} ({selectedCount}/{count})
                                        </button>
                                    );
                                })}
                            </div>
                        </div>

                        {/* DATE SECTIONS with classified groups */}
                        {dates.map(date => {
                            const dayGroups = byDateClassified[date];
                            if (!dayGroups) return null;

                            const hasEvents = Object.values(dayGroups).some(arr => arr.length > 0);
                            if (!hasEvents) return null;

                            const dh = fmtDate(date);

                            return (
                                <div key={date} className="selection-day-group">
                                    <div className="selection-day-header">
                                        <span>{dh.weekday} {dh.day} {dh.month}</span>
                                        <span className="text-xs text-gray-600 font-normal">{date}</span>
                                    </div>

                                    {classOrder.map(cls => {
                                        const cc = CLASS_COLORS[cls];

                                        return sectionOrder.map(sec => {
                                            const key = `${cls}|${sec}`;
                                            const evs = dayGroups[key];
                                            if (!evs || evs.length === 0) return null;

                                            const sc = secColors[sec];
                                            const allSel = evs.every(e => selectedIds.has(e.id));

                                            return (
                                                <div key={key} className="selection-section">
                                                    <div
                                                        className={`selection-section-title ${cc.cssClass}`}
                                                        style={{
                                                            background: `linear-gradient(90deg, ${cc.bg}, ${sc.bg})`,
                                                            borderLeft: `3px solid ${cc.border}`,
                                                        }}
                                                        onClick={() => toggleGroup(evs)}
                                                    >
                                                        <div className={`sel-cb ${allSel ? 'checked' : ''}`}>{allSel ? '\u2713' : ''}</div>
                                                        <span style={{ fontWeight: 700, fontSize: '0.7rem' }}>
                                                            <span style={{ color: cc.text }}>{cls.toUpperCase()}</span>
                                                            <span style={{ color: 'rgba(255,255,255,0.25)', margin: '0 4px' }}>/</span>
                                                            <span style={{ color: sc.text }}>{sec.toUpperCase()}</span>
                                                            <span style={{ color: 'rgba(255,255,255,0.3)', fontWeight: 400, marginLeft: 8 }}>({evs.length})</span>
                                                        </span>
                                                    </div>
                                                    {evs.map(ev => {
                                                        const checked = selectedIds.has(ev.id);
                                                        return (
                                                            <div key={ev.id} className="sel-event-row" onClick={() => toggleEvent(ev.id)}>
                                                                <div className={`sel-cb ${checked ? 'checked' : ''}`}>{checked ? '\u2713' : ''}</div>
                                                                {ev.model && <span className="font-bold text-gray-400" style={{ fontSize: '0.65rem', width: 45 }}>{ev.model}</span>}
                                                                <span className="text-gray-200" style={{ minWidth: 120 }}>{ev.eventName}</span>
                                                                <span className="text-gray-500" style={{ fontSize: '0.6rem', width: 80 }}>{ev.startTime}-{ev.endTime || '??'}</span>
                                                                <span className="sel-crew-preview">{ev.personnel.join(', ')}</span>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            );
                                        });
                                    })}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // â”€â”€â”€ PERSONNEL CHIP â”€â”€â”€

        const PersonnelChip = ({ name, roster, conflictText, onRemove, eventId, inPicker, isBusy, onDragStart: onDS, onDragEnd: onDE, onShowTooltip, onHideTooltip }) => {
            const colors = chipColor(name, roster);

            const handleDragStart = (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({ person: name, sourceEventId: eventId || null }));
                e.dataTransfer.effectAllowed = 'copyMove';
                e.currentTarget.style.opacity = '0.4';
                if (onDS) onDS(name, eventId);
            };

            const handleDragEnd = (e) => {
                e.currentTarget.style.opacity = '1';
                if (onDE) onDE();
            };

            const hasCon = !!conflictText;

            const handleMouseEnter = (e) => {
                if (hasCon && onShowTooltip) {
                    const rect = e.currentTarget.getBoundingClientRect();
                    onShowTooltip(`Also on: ${conflictText}`, rect);
                }
            };

            return (
                <span
                    className={`chip ${hasCon ? 'chip-conflict' : ''} ${inPicker ? 'picker-chip' : ''} ${isBusy ? 'busy' : ''}`}
                    style={{ background: colors.bg, color: colors.text }}
                    draggable
                    onDragStart={handleDragStart}
                    onDragEnd={handleDragEnd}
                    onMouseEnter={handleMouseEnter}
                    onMouseLeave={onHideTooltip}
                    title={hasCon ? undefined : name}
                >
                    {name}
                    {hasCon && <span className="conflict-icon">!</span>}
                    {onRemove && <span className="chip-remove" onClick={(e) => { e.stopPropagation(); e.preventDefault(); onRemove(name); }}>âœ•</span>}
                </span>
            );
        };

        // â”€â”€â”€ EVENT CARD â”€â”€â”€

        const EventCard = ({ event, top, height, roster, conflicts, onRemove, onAdd, onDS, onDE, onShowTooltip, onHideTooltip }) => {
            const [dragOver, setDragOver] = useState(false);

            const sMin = evStart(event);
            const eMin = evEnd(event);
            const leftPct = timePct(sMin);
            const widthPct = timePct(eMin) - leftPct;

            const cCount = eventConflictCount(event.id, conflicts);
            const secClass = `event-card-${event.section.toLowerCase()}`;
            const labelClass = `label-${event.section.toLowerCase()}`;
            const typeLabel = event.section === 'Flying' ? (event.model || 'FLT') : event.section === 'Ground' ? 'GND' : 'NA';

            // Flight bar (ETDâ†’ETA within the card)
            let flightBar = null;
            if (event.section === 'Flying' && event.etd && event.eta) {
                const etdMin = timeToMinutes(event.etd);
                const etaMin = timeToMinutes(event.eta);
                const dur = eMin - sMin;
                if (dur > 0 && etdMin != null && etaMin != null) {
                    const fLeft = Math.max(0, (etdMin - sMin) / dur * 100);
                    const fWidth = Math.max(0, (etaMin - etdMin) / dur * 100);
                    flightBar = (
                        <div className="flight-bar-row">
                            <div className="flight-bar-track">
                                <div className="flight-bar-fill" style={{ left: `${fLeft}%`, width: `${fWidth}%` }}>
                                    <span className="flight-time-marker etd" style={{ left: 0 }}>{event.etd}</span>
                                    <span className="flight-time-marker eta" style={{ right: 0 }}>{event.eta}</span>
                                </div>
                            </div>
                        </div>
                    );
                }
            }

            const handleDragOver = (e) => {
                if (event.readonly) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                setDragOver(true);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setDragOver(false);
                if (event.readonly) return;
                try {
                    const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                    if (data.person && !event.personnel.includes(data.person)) {
                        onAdd(event.id, data.person, data.sourceEventId);
                    }
                } catch (err) {}
            };

            // Build conflict summary for badge tooltip
            let badgeTooltip = '';
            if (cCount > 0) {
                const ec = conflicts.get(event.id);
                const lines = [];
                ec.forEach((confList, person) => {
                    confList.forEach(c => {
                        const m = c.model ? `${c.model} ` : '';
                        lines.push(`${person} â†’ ${m}${c.eventName} ${c.startTime}-${c.endTime || '??'}`);
                    });
                });
                badgeTooltip = lines.join('\n');
            }

            return (
                <div
                    className={`event-card ${secClass} ${dragOver ? 'drag-over' : ''}`}
                    style={{ left: `${leftPct}%`, width: `${Math.max(widthPct, 4)}%`, top: `${top}px`, height: `${height}px` }}
                    onDragOver={handleDragOver}
                    onDragLeave={() => setDragOver(false)}
                    onDrop={handleDrop}
                >
                    {cCount > 0 && (
                        <div className="conflict-badge"
                            onMouseEnter={(e) => { if (onShowTooltip) { onShowTooltip(badgeTooltip, e.currentTarget.getBoundingClientRect()); } }}
                            onMouseLeave={onHideTooltip}
                        >
                            {cCount}
                        </div>
                    )}
                    <div className="event-title-bar">
                        <span className={`event-type-label ${labelClass}`}>{typeLabel}</span>
                        <span className="event-name-text">{event.eventName}</span>
                        <span className="event-time-text">{event.startTime}-{event.endTime || '??'}</span>
                    </div>
                    {flightBar}
                    <div className="event-crew-area" onDragOver={handleDragOver} onDragLeave={() => setDragOver(false)} onDrop={handleDrop}>
                        {event.personnel.map(person => (
                            <PersonnelChip
                                key={person}
                                name={person}
                                roster={roster}
                                conflictText={getConflictText(event.id, person, conflicts)}
                                onRemove={event.readonly ? null : (n) => onRemove(event.id, n)}
                                eventId={event.id}
                                onDS={onDS}
                                onDE={onDE}
                                onShowTooltip={onShowTooltip}
                                onHideTooltip={onHideTooltip}
                            />
                        ))}
                        {!event.readonly && <span className="add-chip" title="Drop personnel here">+</span>}
                    </div>
                </div>
            );
        };

        // â”€â”€â”€ DAY COLUMN â”€â”€â”€

        const DayColumn = ({ date, events, roster, conflicts, onRemove, onAdd, onDS, onDE, onShowTooltip, onHideTooltip }) => {
            const hdr = fmtDate(date);
            const today = new Date().toISOString().slice(0, 10);
            const isToday = date === today;

            const sectionData = useMemo(() => {
                const result = {};
                SECTION_ORDER.forEach(sec => {
                    const secEvts = events.filter(ev => ev.section === sec);
                    result[sec] = { events: secEvts, layout: buildLayout(secEvts) };
                });
                return result;
            }, [events]);

            return (
                <div className="day-column" style={{ borderColor: isToday ? 'rgba(59,130,246,0.25)' : undefined }}>
                    <div className="day-header" style={{ borderBottom: isToday ? '2px solid #3b82f6' : undefined }}>
                        <div style={{ textAlign: 'center' }}>
                            <div style={{ fontWeight: 700, fontSize: '0.8rem', color: 'white' }}>{hdr.weekday}</div>
                            <div style={{ fontSize: '0.65rem', color: '#94a3b8' }}>{hdr.day} {hdr.month}</div>
                        </div>
                        <div className="timeline-ruler">
                            {[6,9,12,15,18].map(h => (
                                <span key={h} style={{ left: `${timePct(h*60)}%` }}>{h}</span>
                            ))}
                        </div>
                    </div>
                    <div className="day-body">
                        {SECTION_ORDER.map(sec => {
                            const { events: secEvts, layout } = sectionData[sec];
                            if (secEvts.length === 0) return null;
                            const divClass = `section-divider section-divider-${sec.toLowerCase()}`;
                            return (
                                <div key={sec}>
                                    <div className={divClass}>{sec === 'NA' ? 'NON-AVAIL' : sec.toUpperCase()}</div>
                                    <div className="section-lanes" style={{ height: `${layout.total || 50}px` }}>
                                        {[6,7,8,9,10,11,12,13,14,15,16,17,18].map(h => (
                                            <div key={h} className="hour-line" style={{ left: `${timePct(h*60)}%` }} />
                                        ))}
                                        {secEvts.map(ev => {
                                            const pos = layout.evMap[ev.id] || { top: 0, height: 40 };
                                            return (
                                                <EventCard
                                                    key={ev.id}
                                                    event={ev}
                                                    top={pos.top}
                                                    height={pos.height}
                                                    roster={roster}
                                                    conflicts={conflicts}
                                                    onRemove={onRemove}
                                                    onAdd={onAdd}
                                                    onDS={onDS}
                                                    onDE={onDE}
                                                    onShowTooltip={onShowTooltip}
                                                    onHideTooltip={onHideTooltip}
                                                />
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                        {events.length === 0 && <div className="empty-day">No selected events</div>}
                    </div>
                </div>
            );
        };

        // â”€â”€â”€ PERSONNEL PICKER â”€â”€â”€

        const PersonnelPicker = ({ roster, allEvents, conflicts, onDS, onDE }) => {
            const [tab, setTab] = useState('All');
            const [search, setSearch] = useState('');

            const cats = useMemo(() => Object.keys(roster).filter(k => roster[k]?.length > 0), [roster]);

            const busySet = useMemo(() => {
                const s = new Set();
                allEvents.forEach(ev => ev.personnel.forEach(p => s.add(p)));
                return s;
            }, [allEvents]);

            // Build per-person conflict summary with actual event details
            const personConflictSummary = useMemo(() => {
                const summary = new Map();
                conflicts.forEach((personMap, eventId) => {
                    personMap.forEach((confList, person) => {
                        if (!summary.has(person)) summary.set(person, new Set());
                        const s = summary.get(person);
                        confList.forEach(c => {
                            const m = c.model ? `${c.model} ` : '';
                            s.add(`${m}${c.eventName} (${c.startTime}-${c.endTime || '??'})`);
                        });
                    });
                });
                // Convert sets to strings
                const result = new Map();
                summary.forEach((detailSet, person) => {
                    result.set(person, [...detailSet].join('; '));
                });
                return result;
            }, [conflicts]);

            const people = useMemo(() => {
                let list;
                if (tab === 'All') {
                    list = Object.entries(roster).flatMap(([cat, members]) => members.map(n => ({ name: n, category: cat })));
                } else {
                    list = (roster[tab] || []).map(n => ({ name: n, category: tab }));
                }
                if (search.trim()) {
                    const q = search.trim().toLowerCase();
                    list = list.filter(p => p.name.toLowerCase().includes(q));
                }
                return list;
            }, [roster, tab, search]);

            return (
                <div className="picker-panel">
                    <div className="flex items-center gap-2 px-2 py-1" style={{ borderBottom: '1px solid rgba(255,255,255,0.05)' }}>
                        <span className="text-xs font-bold text-gray-600 uppercase tracking-wider mr-1" style={{ flexShrink: 0 }}>Picker</span>
                        <div className="picker-tabs flex-1">
                            <div className={`picker-tab ${tab === 'All' ? 'active' : ''}`} onClick={() => setTab('All')}>All</div>
                            {cats.map(c => (
                                <div key={c} className={`picker-tab ${tab === c ? 'active' : ''}`} onClick={() => setTab(c)}>{c}</div>
                            ))}
                        </div>
                        <span className="text-gray-600" style={{ fontSize: '0.5rem', flexShrink: 0, display: 'flex', alignItems: 'center', gap: 4 }}>
                            <span style={{ width: 5, height: 5, borderRadius: '50%', background: '#f59e0b', display: 'inline-block' }}></span>
                            assigned
                        </span>
                        <input className="picker-search" placeholder="Search..." value={search} onChange={e => setSearch(e.target.value)} />
                    </div>
                    <div className="picker-body">
                        {people.map(p => (
                            <PersonnelChip
                                key={p.name}
                                name={p.name}
                                roster={roster}
                                conflictText={personConflictSummary.get(p.name) || null}
                                inPicker
                                isBusy={busySet.has(p.name)}
                                onDS={onDS}
                                onDE={onDE}
                            />
                        ))}
                        {people.length === 0 && <span className="text-xs text-gray-600 p-2">No results</span>}
                    </div>
                </div>
            );
        };

        // â”€â”€â”€ CHANGE SUMMARY (v3 â€” net changes with grouping) â”€â”€â”€

        const NetChangeEntry = ({ inst, formatEvent, onUndo }) => {
            if (inst.type === 'move') {
                return (
                    <div className="change-entry" style={{ flexDirection: 'column', gap: 2 }}>
                        <div style={{ display: 'flex', alignItems: 'flex-start', gap: 6, width: '100%' }}>
                            <span style={{ color: '#3b82f6', fontWeight: 700, fontSize: '0.7rem', flexShrink: 0 }}>&rarr;</span>
                            <div className="change-detail" style={{ flex: 1 }}>
                                <span style={{ color: 'rgba(255,255,255,0.5)' }}>{formatEvent(inst.source)}</span>
                                <span style={{ color: '#3b82f6', margin: '0 4px' }}>&rarr;</span>
                                <span style={{ color: 'rgba(255,255,255,0.7)' }}>{formatEvent(inst.target)}</span>
                            </div>
                            <span className="change-undo" onClick={onUndo} title="Undo all">â†©</span>
                        </div>
                        <div style={{ paddingLeft: 18, color: '#93c5fd', fontSize: '0.55rem', lineHeight: 1.4 }}>
                            {inst.persons.join(', ')}
                        </div>
                    </div>
                );
            }
            if (inst.type === 'add') {
                return (
                    <div className="change-entry">
                        <span className="change-icon-add">+</span>
                        <div className="change-detail">
                            <span style={{ color: 'rgba(255,255,255,0.5)' }}>Add to </span>{formatEvent(inst.target)}
                            <br/><span style={{ color: '#6ee7b7' }}>{inst.persons.join(', ')}</span>
                        </div>
                        <span className="change-undo" onClick={onUndo} title="Undo all">â†©</span>
                    </div>
                );
            }
            return (
                <div className="change-entry">
                    <span className="change-icon-remove">&minus;</span>
                    <div className="change-detail">
                        <span style={{ color: 'rgba(255,255,255,0.5)' }}>Remove from </span>{formatEvent(inst.source)}
                        <br/><span style={{ color: '#fca5a5' }}>{inst.persons.join(', ')}</span>
                    </div>
                    <span className="change-undo" onClick={onUndo} title="Undo all">â†©</span>
                </div>
            );
        };

        const ChangeSummary = ({ changes, onUndoGroup, onClearAll, onCopy }) => {
            const netInstructions = useMemo(() => computeNetChanges(changes), [changes]);

            const byDate = useMemo(() => {
                const m = {};
                netInstructions.forEach(inst => {
                    if (!m[inst.date]) m[inst.date] = [];
                    m[inst.date].push(inst);
                });
                return m;
            }, [netInstructions]);

            const sortedDates = Object.keys(byDate).sort();
            const netCount = netInstructions.length;

            const formatEvent = (meta) => {
                if (!meta) return '';
                const model = meta.eventModel ? `${meta.eventModel} | ` : '';
                return `${model}${meta.eventName} (${meta.eventTime})`;
            };

            return (
                <div className="change-summary-panel">
                    <div className="change-summary-header">
                        <span>Change Summary</span>
                        <span className="text-xs font-normal text-gray-500">
                            {netCount > 0 ? netCount : ''}
                            {netCount > 0 && netCount !== changes.length && (
                                <span style={{ color: 'rgba(255,255,255,0.2)', marginLeft: 4 }}>({changes.length} raw)</span>
                            )}
                        </span>
                    </div>
                    <div className="change-list">
                        {sortedDates.length === 0 && changes.length === 0 && (
                            <div className="text-center text-gray-600 text-xs py-8">
                                No changes yet.<br/>Drag personnel to events<br/>or remove with âœ•.
                            </div>
                        )}
                        {sortedDates.length === 0 && changes.length > 0 && (
                            <div className="text-center text-gray-600 text-xs py-8">
                                All changes cancel out.<br/>Net effect: no changes.
                            </div>
                        )}
                        {sortedDates.map(date => {
                            const h = fmtDate(date);
                            return (
                                <div key={date}>
                                    <div className="change-date-group">{h.full}</div>
                                    {byDate[date].map((inst, i) => (
                                        <NetChangeEntry
                                            key={`${date}-${i}`}
                                            inst={inst}
                                            formatEvent={formatEvent}
                                            onUndo={() => onUndoGroup(inst.rawIndices)}
                                        />
                                    ))}
                                </div>
                            );
                        })}
                    </div>
                    {changes.length > 0 && (
                        <div className="change-summary-footer">
                            <button onClick={onCopy} className="bg-blue-600 hover:bg-blue-500 text-white">Copy</button>
                            <button onClick={onClearAll} className="bg-transparent text-red-400 hover:bg-red-900/30" style={{ border: '1px solid rgba(239,68,68,0.3)' }}>Clear All</button>
                        </div>
                    )}
                </div>
            );
        };

        // â”€â”€â”€ SCHEDULER VIEW â”€â”€â”€

        const SchedulerView = ({ allEvents, roster, dates, initialSelectedIds, initialNaCats, onChangeSelection }) => {
            const [workingEvents, setWorkingEvents] = useState([]);
            const [changes, setChanges] = useState([]);
            const [savedShow, setSavedShow] = useState(false);
            const [tooltip, setTooltip] = useState(null);
            const timelineRef = useRef(null);
            const initialized = useRef(false);

            const showTooltip = useCallback((text, rect) => {
                setTooltip({ text, x: rect.left + rect.width / 2, y: rect.bottom + 6 });
            }, []);
            const hideTooltip = useCallback(() => setTooltip(null), []);

            // Initialize working events from allEvents (no changes recorded)
            useEffect(() => {
                initialized.current = false;
                setWorkingEvents(allEvents.map(ev => ({ ...ev, personnel: [...ev.personnel] })));
                setChanges([]);
                // Use requestAnimationFrame to ensure state is settled before enabling change tracking
                requestAnimationFrame(() => { initialized.current = true; });
            }, [allEvents]);

            // Visible events filter
            const visibleEvents = useMemo(() => {
                return workingEvents.filter(ev => {
                    if (ev.readonly) return false;
                    if (ev.section === 'NA') {
                        return ev.personnel.some(p => {
                            const c = personCat(p, roster);
                            return c && initialNaCats.has(c);
                        });
                    }
                    return initialSelectedIds.has(ev.id);
                });
            }, [workingEvents, initialSelectedIds, initialNaCats, roster]);

            // Events by date
            const eventsByDate = useMemo(() => {
                const m = {};
                dates.forEach(d => { m[d] = []; });
                visibleEvents.forEach(ev => { if (m[ev.date]) m[ev.date].push(ev); });
                return m;
            }, [visibleEvents, dates]);

            // Conflict detection on ALL events
            const conflicts = useMemo(() => detectConflicts(workingEvents), [workingEvents]);

            // Auto-save changes
            useEffect(() => {
                if (!initialized.current) return;
                saveState(changes, initialSelectedIds, initialNaCats);
                if (changes.length > 0) {
                    setSavedShow(true);
                    const t = setTimeout(() => setSavedShow(false), 2000);
                    return () => clearTimeout(t);
                }
            }, [changes]);

            // Add person to event (from picker or another event)
            const handleAdd = useCallback((targetId, person, sourceId) => {
                if (!initialized.current) return;

                const newChanges = [];

                setWorkingEvents(prev => {
                    const next = prev.map(ev => ({ ...ev, personnel: [...ev.personnel] }));
                    const target = next.find(e => e.id === targetId);
                    if (!target || target.personnel.includes(person)) return prev;

                    // Remove from source if moving
                    if (sourceId) {
                        const source = next.find(e => e.id === sourceId);
                        if (source) {
                            source.personnel = source.personnel.filter(p => p !== person);
                            newChanges.push({
                                type: 'remove', person, date: source.date,
                                eventSection: source.section, eventModel: source.model,
                                eventName: source.eventName, eventTime: source.startTime,
                                eventId: source.id,
                            });
                        }
                    }

                    target.personnel.push(person);
                    newChanges.push({
                        type: 'add', person, date: target.date,
                        eventSection: target.section, eventModel: target.model,
                        eventName: target.eventName, eventTime: target.startTime,
                        eventId: target.id,
                    });

                    return next;
                });

                // Record changes after state update (newChanges populated synchronously in updater)
                if (newChanges.length > 0) {
                    setChanges(c => [...c, ...newChanges]);
                }
            }, []);

            // Remove person from event
            const handleRemove = useCallback((eventId, person) => {
                if (!initialized.current) return;

                setWorkingEvents(prev => {
                    const next = prev.map(ev => ({ ...ev, personnel: [...ev.personnel] }));
                    const event = next.find(e => e.id === eventId);
                    if (!event) return prev;
                    event.personnel = event.personnel.filter(p => p !== person);
                    // Record change inside updater for React 18 batching atomicity
                    setChanges(c => [...c, {
                        type: 'remove', person, date: event.date,
                        eventSection: event.section, eventModel: event.model,
                        eventName: event.eventName, eventTime: event.startTime,
                        eventId: event.id,
                    }]);
                    return next;
                });
            }, []);

            // Undo a group of changes (reverse chronological order)
            const handleUndoGroup = useCallback((indices) => {
                if (!indices || indices.length === 0) return;
                const sortedDesc = [...indices].sort((a, b) => b - a);
                setWorkingEvents(prev => {
                    const next = prev.map(ev => ({ ...ev, personnel: [...ev.personnel] }));
                    sortedDesc.forEach(idx => {
                        const ch = changes[idx];
                        if (!ch) return;
                        const event = next.find(e => e.id === ch.eventId);
                        if (!event) return;
                        if (ch.type === 'add') {
                            event.personnel = event.personnel.filter(p => p !== ch.person);
                        } else {
                            if (!event.personnel.includes(ch.person)) event.personnel.push(ch.person);
                        }
                    });
                    return next;
                });
                const indexSet = new Set(indices);
                setChanges(prev => prev.filter((_, i) => !indexSet.has(i)));
            }, [changes]);

            // Clear all
            const handleClearAll = useCallback(() => {
                setWorkingEvents(allEvents.map(ev => ({ ...ev, personnel: [...ev.originalPersonnel] })));
                setChanges([]);
                clearState();
            }, [allEvents]);

            // Copy (net-change format â€” human-readable instructions)
            const handleCopy = useCallback(() => {
                const netInstructions = computeNetChanges(changes);
                if (netInstructions.length === 0) return;
                const lines = [];
                const byDate = {};
                netInstructions.forEach(inst => {
                    if (!byDate[inst.date]) byDate[inst.date] = [];
                    byDate[inst.date].push(inst);
                });
                Object.keys(byDate).sort().forEach(date => {
                    const h = fmtDate(date);
                    lines.push(`--- ${h.full} ---`);
                    byDate[date].forEach(inst => {
                        const fmtEvt = (meta) => {
                            if (!meta) return '';
                            const mdl = meta.eventModel ? `${meta.eventModel} | ` : '';
                            return `${mdl}${meta.eventName} (${meta.eventTime})`;
                        };
                        if (inst.type === 'move') {
                            lines.push(`  MOVE: ${fmtEvt(inst.source)}  -->  ${fmtEvt(inst.target)}`);
                            lines.push(`        ${inst.persons.join(', ')}`);
                        } else if (inst.type === 'add') {
                            lines.push(`  ADD to ${fmtEvt(inst.target)}:`);
                            lines.push(`        ${inst.persons.join(', ')}`);
                        } else {
                            lines.push(`  REMOVE from ${fmtEvt(inst.source)}:`);
                            lines.push(`        ${inst.persons.join(', ')}`);
                        }
                    });
                    lines.push('');
                });
                navigator.clipboard.writeText(lines.join('\n').trim()).catch(() => {});
            }, [changes]);

            const scrollToDay = (date) => {
                const idx = dates.indexOf(date);
                if (idx >= 0 && timelineRef.current) {
                    timelineRef.current.scrollTo({ left: idx * DAY_COL_WIDTH, behavior: 'smooth' });
                }
            };

            const conflictCount = useMemo(() => {
                const people = new Set();
                conflicts.forEach(pm => pm.forEach((_, p) => people.add(p)));
                return people.size;
            }, [conflicts]);

            const today = new Date().toISOString().slice(0, 10);

            return (
                <div className="app-layout">
                    <div className="app-header">
                        <div className="flex items-center gap-4">
                            <div>
                                <h1 className="text-sm font-bold text-white tracking-tight">
                                    TPS INTERACTIVE SCHEDULER
                                    <span className={`saved-indicator ${savedShow ? 'show' : ''}`}>saved</span>
                                </h1>
                                <p className="text-xs text-gray-500">
                                    {visibleEvents.length} events
                                    {conflictCount > 0 && <span className="text-red-400 ml-2">âš  {conflictCount} conflict{conflictCount > 1 ? 's' : ''}</span>}
                                </p>
                            </div>
                            <div className="day-tabs ml-4">
                                {dates.map(d => {
                                    const h = fmtDate(d);
                                    return <div key={d} className={`day-tab ${d === today ? 'today' : ''}`} onClick={() => scrollToDay(d)}>{h.weekday} {h.day}</div>;
                                })}
                            </div>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={onChangeSelection} className="filter-btn">Edit Selection</button>
                            <button onClick={() => { if (changes.length > 0 && !confirm('Discard all changes and reload?')) return; window.location.reload(); }} className="filter-btn" style={{ borderColor: 'rgba(59,130,246,0.3)', color: '#60a5fa' }}>Refresh</button>
                        </div>
                    </div>

                    <div className="timeline-area" ref={timelineRef}>
                        <div className="days-container">
                            {dates.map(date => (
                                <DayColumn
                                    key={date}
                                    date={date}
                                    events={eventsByDate[date] || []}
                                    roster={roster}
                                    conflicts={conflicts}
                                    onRemove={handleRemove}
                                    onAdd={handleAdd}
                                    onShowTooltip={showTooltip}
                                    onHideTooltip={hideTooltip}
                                />
                            ))}
                        </div>
                    </div>

                    <PersonnelPicker roster={roster} allEvents={workingEvents} conflicts={conflicts} />

                    <ChangeSummary
                        changes={changes}
                        onUndoGroup={handleUndoGroup}
                        onClearAll={handleClearAll}
                        onCopy={handleCopy}
                    />

                    {tooltip && (
                        <div className="conflict-tooltip-portal" style={{
                            left: tooltip.x, top: tooltip.y,
                            transform: 'translateX(-50%)',
                        }}>
                            {tooltip.text}
                        </div>
                    )}
                </div>
            );
        };

        // ==========================================
        // APP
        // ==========================================

        function App() {
            const [screen, setScreen] = useState('loading');
            const [allEvents, setAllEvents] = useState([]);
            const [roster, setRoster] = useState({});
            const [dates, setDates] = useState([]);
            const [selectedIds, setSelectedIds] = useState(new Set());
            const [naCats, setNaCats] = useState(new Set());
            const [progress, setProgress] = useState('Initializing...');
            const [error, setError] = useState(null);

            useEffect(() => {
                const load = async () => {
                    try {
                        setProgress('Fetching schedule data...');
                        let loadedRoster, loadedEvents, loadedDates;

                        try {
                            const [rosterRes, batchRes] = await Promise.all([
                                fetch(`${API_URL}?type=roster`),
                                fetch(`${API_URL}?type=batch`)
                            ]);
                            const rosterJson = await rosterRes.json();
                            const batchJson = await batchRes.json();
                            if (rosterJson.error) throw new Error(rosterJson.message);
                            if (batchJson.error) throw new Error(batchJson.message);
                            loadedRoster = rosterJson.roster;
                            loadedDates = batchJson.days.map(d => d.isoDate);
                            loadedEvents = mergeDuplicateEvents(transformBatchData(batchJson, loadedRoster), loadedRoster);
                        } catch (apiErr) {
                            console.warn('API failed, using sample data:', apiErr.message);
                            setProgress('Using sample data...');
                            loadedRoster = SAMPLE_ROSTER;
                            loadedDates = SAMPLE_DATES;
                            loadedEvents = buildSampleEvents();
                        }

                        const filtered = {};
                        Object.entries(loadedRoster).forEach(([k, v]) => { if (v?.length > 0) filtered[k] = v; });

                        setRoster(filtered);
                        setDates(loadedDates);
                        setAllEvents(loadedEvents);

                        // Check for saved state
                        const saved = loadState();
                        if (saved && saved.selectedIds.size > 0) {
                            setSelectedIds(saved.selectedIds);
                            setNaCats(saved.naCats);
                        }

                        setScreen('selection');
                    } catch (err) {
                        setError(err.message);
                    }
                };
                load();
            }, []);

            const handleContinue = (ids, cats) => {
                setSelectedIds(ids);
                setNaCats(cats);
                setScreen('scheduler');
            };

            if (error) {
                return (
                    <div className="loading-screen">
                        <div className="text-red-400 text-center">
                            <div className="text-lg font-bold mb-2">Error</div>
                            <div className="text-sm text-gray-400 mb-4">{error}</div>
                            <button onClick={() => window.location.reload()} className="px-4 py-2 bg-blue-600 rounded-lg text-white font-bold text-sm">Retry</button>
                        </div>
                    </div>
                );
            }

            if (screen === 'loading') return <LoadingScreen progress={progress} />;

            if (screen === 'selection') {
                return (
                    <EventSelectionScreen
                        allEvents={allEvents}
                        roster={roster}
                        dates={dates}
                        onContinue={handleContinue}
                        initialSelected={selectedIds}
                        initialNaCats={naCats}
                    />
                );
            }

            return (
                <SchedulerView
                    allEvents={allEvents}
                    roster={roster}
                    dates={dates}
                    initialSelectedIds={selectedIds}
                    initialNaCats={naCats}
                    onChangeSelection={() => setScreen('selection')}
                />
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
